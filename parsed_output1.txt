!--------------------------------------------------
subroutine ChebyshevPropagator(TimeStep,Psi,ntot)
use mod_Hamiltonian
implicit none
!
!   chebyshev propagation for a Hermitian matrix with
!   eigenvalues between -1 and 1.
!
!   On input  Psi contains the initial wavefunction.
!   On output Psi contains the updated wavefunction.
real*8, intent(IN) :: TimeStep
integer, intent(IN) :: ntot
complex*16, dimension(ntot), intent(INOUT) :: Psi
!
!   i d \psi/dt = H \psi,  where operator H is hermitian with
!                          eigenvalues between -1 and 1.
!
! The Hamiltonian is supplied by external routine HamiltonianC
! with complex arguments.
!
!   Formally,
!      \psi(t) = \exp( -i H t ) \psi(0)
!              = (J_0(t) + 2 \sum_{n=1}^\infty J_n(t) (-i)^n T_n(H)) \psi(0)
!
!   where
!      J_n(x) is the Bessel function, and
!      T_n(x) are the Chebyshev polynomials determined by
!
!      T_n(x)= 2 x T_{n-1}(x) - T_{n-2}(x);      T_0(x)=1;  T_1(x)=x
!
!   Note that in estimating the upper limit to the sum
!   over n I use that J_n(x) decays exponentially for n>x.
!
!  This equation follows from equation 9.6.34 of Abramowitz and Stegun
!        e^{zx}= I_0(z) + 2 \sum_{n=1}^\infty I_n(z) T_n(x)
!  and 
!        I_nu(z)=e^{-nu pi i/2} J_nu(z e^{pi i/2}) or
!                       I_nu(-iz)= e^{-nu pi i/2} J_nu(z)
!
!
!  For the time-dependent Schrodinger equation use the BesselJ series 
!                       as it converges uniformly along the
!                       Imaginary axis.
!  The BesselI series converges uniformly along the Real axis.
!
!  We note |J_nu(z)|<1 and 
!      J_nu(z) ~ 1/\sqrt(2 pi nu) *  (e z/(2nu))^nu for large nu
!  
real*8 :: epsilon
complex*16, dimension(:), allocatable :: PsiPlus1, Psi0, PsiMinus1
integer :: i
real*8 :: X,Y,Z,Ham
complex*16 ::  CX, phase,CY
integer :: NZ, ChebyshevOrder, Order
real*8, dimension(:), allocatable :: BesselJ
integer :: iunit=67
logical,save :: print=.false.
real*8, parameter :: pi=3.14159265359d0 
real*8, parameter :: e=2.71828182845904523d0
epsilon=1e-15   ! requested accuracy
if(print) then
    open(iunit,file='cheby.dat')
    write(iunit,*) '#'
    write(iunit,*) '# Scaled Time Step =',TimeStep
endif
ChebyshevOrder=nint(TimeStep)+5
! from large z behavior of BesselJ
Y=0.5d0*e*TimeStep
X= (Y/ChebyshevOrder)**ChebyshevOrder/dsqrt(2d0*pi*ChebyshevOrder)
do while (X.gt.epsilon)
    ChebyshevOrder=ChebyshevOrder+10
    X= (Y/ChebyshevOrder)**ChebyshevOrder/dsqrt(2d0*pi*ChebyshevOrder)
enddo
! this is a convervative upper bound
allocate(BesselJ(0:ChebyshevOrder))
call DBESJ(TimeStep,0d0,ChebyshevOrder+1,BesselJ,NZ)
if(NZ.ne.0.and.print) then
    !write(6,*) '# Warning from DBESJ: NZ=',NZ
    !write(6,*) '#    BesselJ_nu(z)=0 for nu >',NZ
    write(iunit,*) '# Warning from DBESJ: NZ=',NZ
    write(iunit,*) '#    BesselJ_nu(z)=0 for nu >',NZ
endif
do i=ChebyshevOrder-1,1,-1 
    if(BesselJ(i).gt.epsilon) exit
enddo
Order=i+1
if(print) write(iunit,*) '# Actual Number of Chebyshev polynomials', Order
if(print) then
    Ham=0.33d0
    write(iunit,*) '#       i       BesselJ(i,x)','                Propagator for H=',Ham
    X=1d0
    CY=BesselJ(0)*X 
    write(iunit,*) 0,BesselJ(0),dreal(CY),dimag(CY)
    phase=dcmplx(0d0,-1d0)
    Y=Ham
    CY=2d0*phase*BesselJ(1)*Y+CY
    write(iunit,*) 1,BesselJ(1),dreal(CY),dimag(CY)
    do i=2,Order
        phase=phase*dcmplx(0d0,-1d0)
        CX=2d0*BesselJ(i)*phase
        Z=2d0*Ham*Y-X
        CY=CY+CX*Z
        write(iunit,*) i,BesselJ(i), dreal(CY),dimag(CY)
        X=Y
        Y=Z
    enddo
    write(iunit,*) '                                ---> ',dcos(-TimeStep*Ham),dsin(-TimeStep*Ham)   
    close(iunit)
    print=.false.    ! turn off further printing
endif
allocate( PsiMinus1(ntot), Psi0(ntot), PsiPlus1(ntot) )
!      T_n(x)= 2 x T_{n-1}(x) - T_{n-2}(x);      T_0(x)=1;  T_1(x)=x
call zcopy(ntot,Psi,1,PsiMinus1,1)
! PsiMinus1=Psi
call HamiltonianC(PsiMinus1,Psi0,ntot)
phase=dcmplx(0d0,-1d0)
CX=2d0*BesselJ(1)*phase
call zscal(ntot,dcmplx(BesselJ(0),0d0),Psi,1)
! Psi=BesselJ(0)*PsiMinus1
call zaxpy(ntot,CX,Psi0,1,Psi,1)
!  Psi=BesselJ(0)*PsiMinus1+CX*Psi0
do i=2,Order
    phase= phase*dcmplx(0d0,-1d0)  !(-i)^{i}
    CX=2d0*BesselJ(i)*phase
    ! update Chebyshev recursion
    ! T_n(x)= 2 x T_{n-1}(x) - T_{n-2}(x)
    call HamiltonianC(Psi0,PsiPlus1,ntot)
    call zscal(ntot,dcmplx(2d0,0d0),PsiPlus1,1)
    call zaxpy(ntot,dcmplx(-1d0,0d0),PsiMinus1,1,PsiPlus1,1)
    !  PsiPlus1=2d0*PsiPlus1-PsiMinus1
    call zaxpy(ntot,CX,PsiPlus1,1,Psi,1)
    !  Psi=Psi+CX*PsiPlus1
    !    = (J_0(t) + 2 \sum_{n=1}^\infty J_n(t) (-i)^n T_n(H)) \psi(0)
    call zcopy(ntot,Psi0,1,PsiMinus1,1)
    ! PsiMinus1=Psi0
    call zcopy(ntot,PsiPlus1,1,Psi0,1)
    ! Psi0=PsiPlus1
enddo
deallocate( PsiMinus1, Psi0, PsiPlus1 )
deallocate(BesselJ)
end subroutine ChebyshevPropagator
